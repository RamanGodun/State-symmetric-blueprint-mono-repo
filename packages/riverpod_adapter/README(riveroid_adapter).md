# Riverpod Adapter

**Riverpod Adapter** provides lightweight glue between your domain/data code and the Riverpod runtime:

- ✅ Ready‑made providers for Firebase (auth, users collection) via `firebase_adapter`.
- ✅ Feature‑level provider bundles (Auth, Email verification, Password reset/change, Profile) that wire **domain contracts** from `features` to concrete infra.
- ✅ Base utilities for async/error handling, overlays, theming, and structured provider logging.
- ✅ Global DI container you can use **outside** widget tree and pass as `ProviderScope.parent`.

This keeps apps and feature modules backend‑agnostic while staying ergonomic in Riverpod.

---

## Installation

Add the package via local path:

```yaml
# apps/<your_app>/pubspec.yaml or packages/<another_package>/pubspec.yaml
dependencies:
  riverpod_adapter:
    path: ../../packages/riverpod_adapter
```

Import public pieces where needed:

```dart
// General helpers / DI / base modules
import 'package:riverpod_adapter/riverpod_adapter.dart';

// Firebase bindings (Auth, Users collection)
import 'package:riverpod_adapter/auth/firebase_providers.dart';

// Feature bundles (Auth, Profile, etc.)
import 'package:riverpod_adapter/features_providers/auth/data_layer_providers.dart';
```

> **Import rule:** Prefer the provided barrels (e.g. `riverpod_adapter.dart`, module barrels) instead of deep file paths.

---

## Directory Structure

```
lib/
├─ auth/
│  ├─ auth_stream_adapter.dart        # AuthGateway ⇢ Stream<AuthSnapshot>
│  ├─ firebase_providers.dart         # FirebaseAuth & Users collection providers
│  └─ *.g.dart                        # generated by riverpod_generator
│
├─ base_modules/
│  ├─ errors_handling/
│  │  ├─ async_value_fold_x.dart      # fold(success/error/loading)
│  │  └─ show_dialog_when_error_x.dart# show failure via overlay
│  ├─ observing/
│  │  ├─ async_value_xx.dart          # debug helpers for AsyncValue
│  │  └─ riverpod_observer.dart       # ProviderObserver with nice logs
│  ├─ overlays/
│  │  └─ overlay_dispatcher_provider.dart # overlay dispatcher + status
│  └─ theme_providers/
│     ├─ theme_provider.dart          # ThemeConfigNotifier + state
│     └─ theme_storage_provider.dart  # GetStorage provider
│
├─ di_container/
│  ├─ di_container.dart               # GlobalDIContainer singleton
│  ├─ i_di_config.dart                # IDIConfig contract
│  ├─ read_di_x_on_context.dart       # context.readDI(...) extension
│  └─ di_config_examples/
│     ├─ di_config_sync.dart          # example overrides (sync)
│     └─ di_config_async.dart         # example overrides (async)
│
├─ features_providers/
│  ├─ auth/                           # wires `features/auth` domain/data
│  ├─ email_verification/             # wires email verification
│  ├─ password_changing_or_reset/     # wires password flows
│  └─ profile/                        # wires profile feature
│
└─ utils/
   ├─ safe_async_state.dart           # guard AsyncNotifier updates after dispose
   └─ typedef_for_riverpod_package.dart
```

---

## Quick Start

### 1) Create a global container in bootstrap

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_adapter/di_container/di_container.dart';

void main() async {
  final parent = ProviderContainer(
    overrides: const [], // or provided by your DI config
    observers: [RiverpodLogger()],
  );

  GlobalDIContainer.initialize(parent);

  runApp(ProviderScope(
    parent: GlobalDIContainer.instance,
    child: const App(),
  ));
}
```

### 2) Provide Firebase bindings (once)

```dart
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:riverpod_adapter/auth/firebase_providers.dart';

// then simply `ref.watch(firebaseAuthProvider)` or `ref.watch(usersCollectionProvider)` wherever needed
```

### 3) Use feature bundles

```dart
import 'package:riverpod_adapter/features_providers/auth/data_layer_providers.dart';
import 'package:riverpod_adapter/features_providers/auth/domain_layer_providers.dart';

final signIn = ref.watch(signInUseCaseProvider);
await signIn('email', 'password');
```

---

## Error Handling & Overlays

Use the provided extensions to keep UI tidy and consistent:

```dart
ref.listenFailureWithAction(
  someAsyncProvider,
  context,
  onConfirmed: () => ref.refresh(someAsyncProvider.future),
);

// Or simple fold
ref.watch(someAsyncProvider).fold(
  onSuccess: (data) => ...,
  onError: (failure) => context.showError(failure.toUIEntity()),
  onLoading: () => ...,
);
```

Overlay status is exposed via `overlayStatusProvider` and updates automatically through `overlayDispatcherProvider`.

---

## Theming

```dart
final theme = ref.watch(themeProvider);
ref.read(themeProvider.notifier).toggleTheme();
```

The notifier persists theme/font to `GetStorage` via `theme_storage_provider.dart`.

---

## Conventions

- Only Riverpod‑specific glue lives here; domain contracts/implementations remain in `features`.
- All Firebase SDK access goes through `firebase_adapter` — this package only consumes its types/providers.
- Prefer **providers/overrides** over global singletons; when needed, use `GlobalDIContainer` for non‑widget code.
- Keep generated files (`*.g.dart`) out of VCS if your repo policy requires; they are produced by `riverpod_generator`.

---

## Development

This monorepo uses [Melos](https://melos.invertase.dev/).

```bash
# From repo root
melos bootstrap

# Only this package
melos exec --scope="riverpod_adapter" -- flutter analyze
melos exec --scope="riverpod_adapter" -- flutter test

# Codegen (required for *.g.dart)
flutter pub run build_runner build --delete-conflicting-outputs
```

---

## License

Licensed under the same terms as the monorepo’s root [LICENSE](../../LICENSE).
