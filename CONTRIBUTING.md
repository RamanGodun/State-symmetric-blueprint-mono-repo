# ✅ Алгоритм розрахунків (перший перенос, RT/2)

## 0) Корзини (6)

1. **Infrastructure** — ігноруємо у вартості міграції
2. **Reused Core** (Domain/Data, статичний UI)
3. **SM+INIT** (цільовий стейт-менеджер + ініціалізація/DI/route)
4. **State Models** (спільні моделі стану у шаред-пакетах)
5. **Overhead (OH)** (адаптери/шви між моделями та SM)
6. **Presentation** (stateful UI, прив’язаний до SM)

> Розмір фічі для відсотків рахуємо як **2+3+4+6**.

---

## 1) Базова лінія (Clean Architecture), **перший перенос**

**Припущення:** під кожен SM пишуть **свої** state models → **переписуємо State Models у всіх місцях використання**.

Для одного плеча:

```
ΔLOC_base_leg
  = Presentation_full_under_target_SM (знаходиться у відповідний теках додатків)
  + State_Models_rewrite (з урахуванням усіх використань цієї моделі, рахується окремо, бо знаходяться окремо)
  + SM+INIT_target (знаходяться у відповідний теках додатків, а також відповідних кастомних флаттер пакетах)
```

Усереднення (уникаємо подвійного рахунку):

```
ROUND_TRIP_BASE_AVG = (ΔLOC_base_RP→CB + ΔLOC_base_CB→RP) / 2
```

---

## 2) Стейт-симетрія (AVLSM / SCSM), **перший перенос**

Для одного плеча:

```
ΔLOC_sym_leg = SM+INIT_target (3) + OH_target_if_new (5)
```

- **AVLSM:** `OH_target_if_new` — **AsyncValueForBloc state model + адаптери під цільовий SM**.
- **SCSM:** `OH_target_if_new` — **адаптери** під цей SM; якщо шов уже існує — 0.

Усереднення:

```
ROUND_TRIP_SYM_AVG = (ΔLOC_sym_RP→CB + ΔLOC_sym_CB→RP) / 2
```

---

## 3) Економія на міграції (лише перенос, без амортизації)

```
SAVINGS_migration = ROUND_TRIP_BASE_AVG − ROUND_TRIP_SYM_AVG
```

---

## 4) Усереднений оверхед для **першого переносу** (без амортизації)

> У цей блок входять **лише адаптери** (корзина 5). **SM+INIT (3) — не OH**.

- **AVLSM:**
  `OH_avg_per_leg = (OH_AsyncValueForBloC_state_model + OH_adapters_RP + OH_adapters_CB) / 2`
- **SCSM:**
  `OH_avg_per_leg = (OH_adapters_RP + OH_adapters_CB) / 2`

> Це дає **середньозважений OH за одне плече** для першого переносу. Амортизацію (ділення на N фіч) робитимемо окремо пізніше.

---

## 5) Відсоток оверхеду від розміру фічі

```
FEATURE_SIZE_TOTAL = (2 + 3 + 4 + 6)   // без інфраструктури і без OH
OH_RATIO = OH_avg_per_leg / FEATURE_SIZE_TOTAL
```

---

## 6) Повна “страхова” вигода (опційно додати зараз)

До `SAVINGS_migration` можна додати економію на тестах/підтримці:

```
MAINT_BENEFIT ≈ (CS_baseline − CS_symmetric) × N_changes × K_change
EXPECTED_PAYOUT = SAVINGS_migration + MAINT_BENEFIT
```

(Для першої ітерації можна звітувати обидві метрики окремо: «перенос» і «перенос+підтримка».)

---

## 7) Перевірка RT/2

Усі «вартість переносу» й «OH» подаємо як **Round-Trip / 2**, тобто **середня ціна одного плеча**. Це йде в порівняння «базова лінія vs стейт-симетрія» для **першого переносу**. Амортизовані оцінки (поділ OH на N) — наступним кроком.
